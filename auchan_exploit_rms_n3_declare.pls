CREATE OR replace PACKAGE auchan_exploit_rms_n3 
AS 
  ------------------------------------------------------------------ 
  -- FUNCTION:  
  -- Purpose:  Recadre les reserves de stock sur CM 
  ------------------------------------------------------------------ 
  FUNCTION Alloc_recadre_stockres_cm( 
    i_item IN item_master.item%TYPE) 
  RETURN BOOLEAN; 
  ------------------------------------------------------------------ 
  -- FUNCTION:  
  -- Purpose:  Delete les brouillons sur RMS 
  ------------------------------------------------------------------    
  FUNCTION Alloc_delete_brouillon_rms( 
    i_item IN item_master.item%TYPE) 
  RETURN BOOLEAN; 
  ------------------------------------------------------------------ 
  -- FUNCTION:  
  -- Purpose:  Injection d'allocations 
  ------------------------------------------------------------------      
  FUNCTION Init_alloc( 
    porin         NUMBER, 
    pstore        NUMBER, 
    ddeliverydate DATE, 
    pquantity     NUMBER, 
    pcontext      VARCHAR2 DEFAULT 'I', 
    sdescription  VARCHAR2 DEFAULT 'No description', 
    scomment      VARCHAR2 DEFAULT 'NO COMMENT') 
  RETURN NUMBER; 
END auchan_exploit_rms_n3; 

CREATE OR replace PACKAGE BODY auchan_exploit_rms_n3 
AS 
  ------------------------------------------------------------------ 
  -- FUNCTION:  
  -- Purpose:  Suppression brouillon allocation 
  ------------------------------------------------------------------ 
  FUNCTION Alloc_delete_brouillon_rms(i_item IN item_master.item%TYPE) 
  RETURN BOOLEAN 
  IS 
    l_alloc_id             rms13.alc_xref.alloc_id%TYPE; 
    l_item_id              rms13.alc_xref.item_id%TYPE; 
    l_count                NUMBER; 
    l_allocated_qty        rms13.alc_xref.allocated_qty%TYPE; 
    l_list_of_allocs       VARCHAR2 (4000); 
    l_wh                   rms13.wh.wh%TYPE; 
    l_store                rms13.store.store%TYPE; 
    l_count_shipped_closed INTEGER; 
    l_count_unshipped      INTEGER; 
    l_pack_ind             CHAR(1); 
    l_source_type          alc_item_source.source_type%TYPE; 
    l_count_ah_init        NUMBER; 
    l_count_ah_fin         NUMBER; 
    l_supprime             NUMBER; 
  BEGIN 
      -- logger le début 
      dbms_output.Put_line('delete_status0 Start:' 
                           ||To_char(SYSDATE, 'yyyy.mm.dd hh24:mi:ss')); 

      -- mettre le compteur d'alloc_header dans le logfile 
      SELECT Count (*) 
      INTO   l_count_ah_init 
      FROM   alloc_header; 

      --write_logfile (Comptage intial: l_count_ah_init) 
      FOR all_id_cklv IN (SELECT DISTINCT item_id, 
                                          alloc_id 
                          FROM   alc_xref 
                          WHERE  item_id = i_item) LOOP 
          BEGIN 
              l_item_id := all_id_cklv.item_id; 

              l_alloc_id := all_id_cklv.alloc_id; 

              dbms_output.Put_line('init_allocation RMS : ' 
                                   ||l_alloc_id 
                                   ||' pour item : ' 
                                   ||l_item_id); 

              -- récupération des détails alloc 
              SELECT wh_id 
              INTO   l_wh 
              FROM   alc_xref 
              WHERE  alloc_id = l_alloc_id 
                     AND ROWNUM = 1; 

              SELECT allocated_qty 
              INTO   l_allocated_qty 
              FROM   alc_xref 
              WHERE  alloc_id = l_alloc_id 
                     AND ROWNUM = 1; 

              SELECT source_type 
              INTO   l_source_type 
              FROM   alc_item_source 
              WHERE  alloc_id = l_alloc_id; 

              SELECT location_id 
              INTO   l_store 
              FROM   alc_item_loc 
              WHERE  alloc_id = l_alloc_id; 

              SELECT pack_ind 
              INTO   l_pack_ind 
              FROM   item_master 
              WHERE  item = l_item_id; 

              -- compter les allocations á supprimer 
              SELECT Count (*) 
              INTO   l_count 
              FROM   alc_xref 
              WHERE  alloc_id = l_alloc_id; 

              IF l_source_type = 3 
              -- si alloc sur stock, supprimer la réservation 
              THEN 
                -- supprimer le réservé entrepot 
                UPDATE item_loc_soh 
                SET    tsf_reserved_qty = tsf_reserved_qty - 
                                          l_count * l_allocated_qty 
                       , 
                       last_update_datetime = SYSDATE, 
                       last_update_id = 'RMS13' 
                WHERE  item = l_item_id 
                       AND loc = l_wh; 

                IF l_pack_ind = 'N' THEN 
                  -- supprimer l'attendu magasin 
                  UPDATE item_loc_soh 
                  SET    tsf_expected_qty = tsf_expected_qty - 
                                            l_count * l_allocated_qty, 
                         last_update_datetime = SYSDATE, 
                         last_update_id = 'RMS13' 
                  WHERE  item = l_item_id 
                         AND loc = l_store; 
                END IF; 

                IF l_pack_ind = 'Y' THEN 
                  FOR c_components IN (SELECT item, 
                                              item_qty 
                                       FROM   packitem_breakout 
                                       WHERE  pack_no = l_item_id) LOOP 
                      -- supprimer le réservé des composant en entrepot 
                      UPDATE item_loc_soh 
                      SET    pack_comp_resv = pack_comp_resv - 
                      l_count * c_components.item_qty * l_allocated_qty, 
                      last_update_datetime = SYSDATE, 
                      last_update_id = 'RMS13' 
                      WHERE  item = c_components.item 
                             AND loc = l_wh; 

                      -- supprimer l'attendu magasin niveau composant 
                      UPDATE item_loc_soh 
                      SET    tsf_expected_qty = tsf_expected_qty - 
                      l_count * c_components.item_qty * l_allocated_qty, 
                      last_update_datetime = SYSDATE, 
                      last_update_id = 'RMS13' 
                      WHERE  item = c_components.item 
                             AND loc = l_store; 
                  END LOOP; 
                END IF; 
              END IF; 

              -- suppression de ALLOC_DETAIL 
              DELETE FROM alloc_detail ad 
              WHERE  alloc_no IN (SELECT xref_alloc_no 
                                  FROM   (SELECT xref_alloc_no, 
                                                 Row_number () 
                                                   over ( 
                                                     PARTITION BY 
                                                   alc_xref.alloc_id 
                                                     ORDER BY xref_id DESC) rno 
                                          FROM   alc_xref 
                                          WHERE  alloc_id = l_alloc_id) 
                                  WHERE  rno <= l_count); 

              -- suppression de ALLOC_HEADER 
              DELETE FROM alloc_header ah 
              WHERE  alloc_no IN (SELECT xref_alloc_no 
                                  FROM   alc_xref 
                                  WHERE  alloc_id = l_alloc_id) 
                     AND NOT EXISTS (SELECT alloc_no 
                                     FROM   alloc_detail ad 
                                     WHERE  ad.alloc_no = ah.alloc_no); 

              -- suppression de ALC_XREF 
              DELETE FROM alc_xref ax 
              WHERE  alloc_id = l_alloc_id 
                     AND NOT EXISTS (SELECT alloc_no 
                                     FROM   alloc_header ah 
                                     WHERE  ax.xref_alloc_no = ah.alloc_no); 

              dbms_output.Put_line('delete_allocation RMS : ' 
                                   ||l_alloc_id 
                                   ||' pour item : ' 
                                   ||l_item_id); 
          -- écrire l'echec dans logfile 
          EXCEPTION 
              WHEN OTHERS THEN 
                dbms_output.Put_line('delete_status0 End Fail:' 
                                     ||To_char(SYSDATE, 'yyyy.mm.dd hh24:mi:ss') 
                                     ||' - ' 
                                     ||SQLERRM); 

                CONTINUE; 
          END; 
      END LOOP; 

      -- écrire le succes dans logfile 
      dbms_output.Put_line('delete_status0 End Ok:' 
                           ||To_char(SYSDATE, 'yyyy.mm.dd hh24:mi:ss')); 

      RETURN TRUE; 
  END alloc_delete_brouillon_rms; 
  ------------------------------------------------------------------ 
  -- FUNCTION:  
  -- Purpose:  Initialisation des allocations 
  ------------------------------------------------------------------ 
  FUNCTION Init_alloc(porin         NUMBER, 
                      pstore        NUMBER, 
                      ddeliverydate DATE, 
                      pquantity     NUMBER, 
                      pcontext      VARCHAR2 DEFAULT 'I', 
                      sdescription  VARCHAR2 DEFAULT 'No description', 
                      scomment      VARCHAR2 DEFAULT 'NO COMMENT') 
  RETURN NUMBER 
  IS 
    alloc_id NUMBER; 
  BEGIN 
      alloc_id := au_alloc_stage_seq.NEXTVAL; 

      INSERT INTO au_alloc_stage 
      (SELECT alloc_id, 
              porin, 
              d.group_no, 
              '989', 
              pstore, 
              1         AS store_channel,--Always 1 
              pquantity AS allocated_qty, 
              ddeliverydate, 
              ddeliverydate, 
              pcontext  AS context_type, 
              au_alloc_stage_seq.NEXTVAL, 
              sdescription, 
              scomment  AS alloc_comment, 
              'R'       AS status, 
              NULL, 
              NULL, 
              NULL, 
              SYSDATE, 
              SYSDATE, 
              NULL, 
              NULL 
       FROM   item_master im 
              inner join deps d 
                      ON d.dept = im.dept 
       WHERE  1 = 1 
              AND im.item_parent = porin); 

      COMMIT; 

      RETURN alloc_id; 
  END init_alloc; 
  ------------------------------------------------------------------ 
  -- FUNCTION:  
  -- Purpose:  Recadrage stock rms 
  ------------------------------------------------------------------ 
  FUNCTION Alloc_recadre_stockres_cm(i_item IN item_master.item%TYPE) 
  RETURN BOOLEAN 
  IS 
    l_comp_adjust_qty rms13.item_loc_soh.pack_comp_resv%TYPE; 
    l_pack_adjust_qty rms13.item_loc_soh.tsf_reserved_qty%TYPE; 
  BEGIN 
      --logging du début de traitement 
      dbms_output.Put_line('RecadrageReserveCM Start:' 
                           ||To_char(SYSDATE, 'yyyy.mm.dd hh24:mi:ss')); 

      FOR c_rec IN (WITH cal_rsv 
                         AS (SELECT item, 
                                    entrepot, 
                                    SUM (qty_rsv) qty_rsv 
                             FROM   (SELECT h.item, 
                                            h.wh 
                                            entrepot 
                                                    , 
                                            SUM (Greatest (Nvl (qty_allocated, 0 
                                                           ) 
                                                           - Nvl ( 
                                                           qty_transferred, 0) 
                                                           - Least 
                                                           ( 
                                                                Nvl ( 
                                                           qty_cancelled 
                                                                , 0) 
                                                           , 
                                                           qty_allocated), 0 
                                                 )) 
                                            qty_rsv 
                                     FROM   rms13.alloc_header h 
                                            inner join rms13.alloc_detail d 
                                                    ON h.alloc_no = d.alloc_no 
                                     WHERE  h.order_no IS NULL 
                                            AND h.status IN ( 'A', 'R' ) 
                                            AND wh = 989 
                                            AND item IN (SELECT item 
                                                         FROM   item_master 
                                                         WHERE 
                                                pack_ind = 'Y' 
                                                AND item = i_item 
                                                AND item_level = 
                                                    tran_level) 
                                     -- CM 
                                     GROUP  BY h.item, 
                                               h.wh 
                                     UNION ALL 
                                     SELECT d.item, 
                                            Decode (h.from_loc, 990, 989, 
                                                                989) entrepot, 
                                            SUM (Greatest (Nvl (d.tsf_qty, 0) 
                                                           - Nvl ( 
                                                           ship_qty, 0) 
                                                           - Nvl ( 
                                                           cancelled_qty, 0), 
                                                 0))                 qty_rsv 
                                     FROM   rms13.tsfhead h 
                                            inner join rms13.tsfdetail d 
                                                    ON h.tsf_no = d.tsf_no 
                                     WHERE  h.status IN ( 'A', 'B', 'L', 'S' ) 
                                            -- transferts approuvés, soumis et selectionnés 
                                            AND h.from_loc = 990 
                                            AND item IN (SELECT item 
                                                         FROM   item_master 
                                                         WHERE 
                                                pack_ind = 'Y' 
                                                AND item = i_item 
                                                AND item_level = 
                                                    tran_level) 
                                     -- CM 
                                     GROUP  BY d.item, 
                                               h.from_loc) 
                             GROUP  BY item, 
                                       entrepot), 
                         stk_theo 
                         AS (-- Stock actuel 
                            SELECT h.item, 
                                   h.loc, 
                                   h.stock_on_hand, 
                                   h.tsf_reserved_qty 
                             FROM   rms13.item_loc_soh h 
                             WHERE  h.loc = 989 
                                    AND item IN (SELECT item 
                                                 FROM   item_master 
                                                 WHERE  pack_ind = 'Y' 
                                                        AND item = i_item 
                                                        AND item_level = 
                                                            tran_level)) 
                    --CM 
                    SELECT * 
                     FROM   (SELECT t.item, 
                                    t.loc, 
                                    t.stock_on_hand, 
                                    t.tsf_reserved_qty, 
                                    Nvl ((SELECT qty_rsv 
                                          FROM   cal_rsv r 
                                          WHERE  r.item = t.item 
                                                 AND r.entrepot = t.loc), 0) 
                                    qty_rsv 
                             FROM   stk_theo t) 
                     WHERE  ( tsf_reserved_qty != qty_rsv ) 
                            AND item IN (SELECT item 
                                         FROM   item_seasons 
                                         WHERE  season_id IN (SELECT season_id 
                                                              FROM   seasons 
                                                              WHERE 
                                                end_date >= get_vdate)) 
                     ORDER  BY item) LOOP 
          FOR c_components IN (SELECT pack_no, 
                                      item, 
                                      item_qty 
                               FROM   rms13.packitem_breakout 
                               WHERE  pack_no = c_rec.item) LOOP 
              l_comp_adjust_qty := 0; 

              SELECT c_components.item_qty * 
                     ( c_rec.qty_rsv - c_rec.tsf_reserved_qty ) 
              INTO   l_comp_adjust_qty 
              FROM   dual; 

              UPDATE item_loc_soh 
              SET    pack_comp_resv = pack_comp_resv + l_comp_adjust_qty, 
                     last_update_datetime = SYSDATE, 
                     last_update_id = 'RMS13' 
              WHERE  loc = c_rec.loc 
                     AND item = c_components.item; 
          END LOOP; 

          l_pack_adjust_qty := c_rec.qty_rsv - c_rec.tsf_reserved_qty; 

          UPDATE item_loc_soh 
          SET    tsf_reserved_qty = tsf_reserved_qty + l_pack_adjust_qty, 
                 last_update_datetime = SYSDATE, 
                 last_update_id = 'RMS13' 
          WHERE  item = c_rec.item 
                 AND loc = c_rec.loc; 

          dbms_output.Put_line('Ajustement stock item : ' 
                               ||c_rec.item 
                               ||' pour loc : ' 
                               ||c_rec.loc); 
      END LOOP; 

      --commit; 
      dbms_output.Put_line('RecadrageReserveCM End:' 
                           ||To_char(SYSDATE, 'yyyy.mm.dd hh24:mi:ss')); 

      COMMIT; 

      RETURN TRUE; 
  EXCEPTION 
    WHEN OTHERS THEN 
               dbms_output.Put_line('RecadrageReserveCM End Fail:' 
                                    ||To_char(SYSDATE, 'yyyy.mm.dd hh24:mi:ss') 
                                    ||' - ' 
                                    ||SQLERRM); 

               ROLLBACK; 

               RETURN FALSE; 
  END alloc_recadre_stockres_cm; 
END auchan_exploit_rms_n3; 